# 场景 24: 并发安全场景

## 场景描述

这是一个并发安全场景示例,演示多个审批人同时审批同一个任务时,系统如何保证并发安全.

**业务背景**: 在高并发审批场景中,多个审批人可能同时操作同一个任务,系统必须保证:
- 并发读取的安全性: 多个 goroutine 可以同时读取任务数据
- 并发更新的原子性: 更新操作是串行化的,不会出现中间状态
- 状态转换的一致性: 并发状态下保证状态转换的正确性
- 数据隔离性: 读取操作返回的数据副本,不会受到并发更新的影响

## 流程结构

```
开始节点 → 审批节点(多人会签) → 结束节点
```

流程说明:
1. **开始节点**: 流程的起点,自动执行
2. **审批节点**: 多人会签审批
   - 审批模式: 多人会签 (ApprovalModeUnanimous)
   - 审批人: approver-001, approver-002, approver-003
3. **结束节点**: 流程的终点

## 关键特性

- **并发安全**: 使用读写锁保证并发访问安全
- **状态一致性**: 并发状态下保证状态转换的正确性
- **原子操作**: 状态转换是原子操作,不会出现中间状态
- **数据隔离**: 读取操作返回数据副本,确保隔离性

## 代码说明

### 主要组件

1. **模板创建** (`createTemplate`):
   - 创建多人会签审批模板
   - 配置审批模式为多人会签 (ApprovalModeUnanimous)

2. **并发测试场景** (`runConcurrentScenarios`):
   - 场景1: 并发读取测试
   - 场景2: 并发更新测试
   - 场景3: 并发审批测试
   - 场景4: 并发读取和更新混合测试

3. **结果输出**:
   - 输出并发测试结果
   - 输出任务状态和审批记录
   - 输出并发安全说明

### 代码结构

```go
main()
  ├── 创建管理器 (TemplateManager, TaskManager)
  ├── 创建模板 (createTemplate)
  └── 运行并发测试场景 (runConcurrentScenarios)
      ├── 场景1: 并发读取测试 (testConcurrentRead)
      ├── 场景2: 并发更新测试 (testConcurrentUpdate)
      ├── 场景3: 并发审批测试 (testConcurrentApproval)
      └── 场景4: 并发读取和更新混合测试 (testConcurrentReadAndUpdate)
```

### 并发读取测试示例

```go
// 并发读取
concurrency := 50
var wg sync.WaitGroup
wg.Add(concurrency)

for i := 0; i < concurrency; i++ {
    go func(id int) {
        defer wg.Done()
        tsk, _ := taskMgr.Get(taskID)
        // 并发读取各种字段
        _ = tsk.GetState()
        _ = tsk.GetCurrentNode()
        _ = tsk.GetUpdatedAt()
        _ = tsk.GetStateHistory()
        _ = tsk.GetRecords()
        _ = tsk.Snapshot()
    }(i)
}
wg.Wait()
```

### 并发更新测试示例

```go
// 并发更新
concurrency := 30
var wg sync.WaitGroup
wg.Add(concurrency)

for i := 0; i < concurrency; i++ {
    go func(id int) {
        defer wg.Done()
        tsk, _ := taskMgr.Get(taskID)
        // 并发更新任务
        _ = tsk.Update(func(t *task.Task) error {
            t.UpdatedAt = time.Now()
            return nil
        })
    }(i)
}
wg.Wait()
```

### 并发审批测试示例

```go
// 并发审批
approvers := []string{"approver-001", "approver-002", "approver-003"}
var wg sync.WaitGroup
wg.Add(len(approvers))

for i, approver := range approvers {
    go func(id int, apr string) {
        defer wg.Done()
        // 并发审批
        err := taskMgr.Approve(taskID, "approval", apr, "审批意见")
        if err != nil {
            // 可能是状态已变更
        }
    }(i, approver)
}
wg.Wait()
```

## 执行方法

### 前置要求

- Go 1.25.4 或更高版本
- 已安装 approval-kit 依赖

### 执行步骤

1. 进入场景目录:
   ```bash
   cd examples/24-concurrent-safety
   ```

2. 运行程序:
   ```bash
   go run main.go
   ```

3. 使用 race detector 检测并发安全问题:
   ```bash
   go run -race main.go
   ```

### 预期输出

程序运行后会输出以下内容:

```
=== 场景 24: 并发安全场景 ===

✓ 模板创建成功: ID=concurrent-safety-template, Name=并发安全测试模板

--- 场景1: 并发读取测试 ---
✓ 任务创建成功: ID=task-1763523616274234000-1
✓ 任务已提交
✓ 并发读取测试完成: 50 个 goroutine, 耗时 214.75µs
  说明: 使用读写锁保证并发读取的安全性,多个 goroutine 可以同时读取任务数据

--- 场景2: 并发更新测试 ---
✓ 任务创建成功: ID=task-1763523616274475000-2
✓ 任务已提交
✓ 并发更新测试完成: 30 个 goroutine, 耗时 36.542µs
  最终状态: submitted, 更新时间: 2025-11-19 11:40:16
  说明: 使用写锁保证并发更新的原子性,更新操作是串行化的

--- 场景3: 并发审批测试 ---
✓ 任务创建成功: ID=task-1763523616274695000-3
✓ 任务已提交
✓ 审批人已设置: [approver-001 approver-002 approver-003]
✓ Goroutine 2: approver-003 审批成功
✓ Goroutine 0: approver-001 审批成功
✓ Goroutine 1: approver-002 审批成功
✓ 并发审批测试完成: 3 个审批人, 耗时 52.875µs
  最终状态: approved
  审批记录数: 3 (期望: 3)
  说明: 使用写锁保证审批操作的原子性,状态转换是串行化的

--- 场景4: 并发读取和更新混合测试 ---
✓ 任务创建成功: ID=task-1763523616274765000-4
✓ 任务已提交
✓ 并发读取和更新混合测试完成: 30 个读取 + 10 个更新, 耗时 54.5µs
  最终状态: submitted
  说明: 读写锁支持并发读取,写操作会阻塞所有读写操作,保证数据一致性
```

**注意**: 
- 任务 ID 是动态生成的,每次运行都会不同
- 时间戳是实际运行时间,每次运行都会不同
- 并发测试的耗时可能因系统负载而有所不同
- 使用 `go run -race` 可以检测并发安全问题

## 验证步骤

1. **验证并发读取安全性**:
   - 检查多个 goroutine 是否可以同时读取任务数据
   - 检查读取操作是否返回正确的数据
   - 检查是否有 race condition

2. **验证并发更新原子性**:
   - 检查多个 goroutine 并发更新时,更新操作是否串行化
   - 检查任务状态是否保持一致
   - 检查是否有数据竞争

3. **验证并发审批安全性**:
   - 检查多个审批人并发审批时,审批操作是否串行化
   - 检查审批记录是否正确记录
   - 检查任务状态转换是否正确

4. **验证并发读取和更新混合场景**:
   - 检查读取和更新混合时,数据是否一致
   - 检查读写锁是否正确工作
   - 检查是否有 race condition

### 验证要点

- ✓ 并发读取安全性: 多个 goroutine 可以同时读取任务数据
- ✓ 并发更新原子性: 更新操作是串行化的,不会出现中间状态
- ✓ 并发审批安全性: 审批操作是串行化的,状态转换正确
- ✓ 数据隔离性: 读取操作返回数据副本,不受并发更新影响

## 并发安全机制说明

### 读写锁机制

`Task` 结构体使用 `sync.RWMutex` 读写锁保证并发安全:

- **读锁 (RLock)**: 多个 goroutine 可以同时获取读锁,用于读取操作
- **写锁 (Lock)**: 只有一个 goroutine 可以获取写锁,用于更新操作
- **读写互斥**: 写操作会阻塞所有读写操作,保证数据一致性

### 并发安全方法

`Task` 结构体提供了以下并发安全方法:

- **GetState()**: 并发安全地获取任务状态
- **GetCurrentNode()**: 并发安全地获取当前节点 ID
- **GetUpdatedAt()**: 并发安全地获取更新时间
- **GetStateHistory()**: 并发安全地获取状态变更历史(返回副本)
- **GetRecords()**: 并发安全地获取审批记录(返回深拷贝)
- **Update(fn)**: 并发安全地更新任务(使用写锁)
- **Snapshot()**: 创建任务快照(并发安全,返回不可变快照)

### 数据隔离性

读取操作返回数据副本,确保隔离性:

- **GetStateHistory()**: 返回状态变更历史的副本
- **GetRecords()**: 返回审批记录的深拷贝
- **Snapshot()**: 返回任务的不可变快照

这样可以确保:
- 读取操作不会受到并发更新的影响
- 外部代码无法直接修改任务内部数据
- 数据隔离性得到保证

### 原子操作

状态转换是原子操作:

- 使用 `Update()` 方法进行状态转换
- `Update()` 方法内部使用写锁,确保原子性
- 状态转换不会出现中间状态
- 状态转换是串行化的

## 适用场景

这个场景适用于以下实际业务场景:

- **高并发审批场景**: 多个审批人同时操作同一个任务
- **并发读取场景**: 多个系统同时查询任务状态
- **并发更新场景**: 多个系统同时更新任务数据
- **混合并发场景**: 读取和更新操作混合的并发场景

## 扩展说明

如果需要扩展此场景,可以考虑:

1. **测试更多并发场景**: 测试更多并发操作的组合
2. **测试性能**: 测试并发场景下的性能表现
3. **测试边界情况**: 测试极端并发场景下的行为
4. **测试错误处理**: 测试并发场景下的错误处理
5. **测试数据一致性**: 测试并发场景下的数据一致性保证

## 相关场景

- **场景 02**: 多人会签审批流程 - 展示了多人会签的基本使用方式
- **场景 22**: 状态变更历史查询场景 - 展示了状态变更历史的查询方式
- **场景 14**: 审批记录查询和分析场景 - 展示了审批记录的查询方式

## 并发安全最佳实践

1. **使用并发安全方法**: 始终使用 `Task` 提供的并发安全方法进行读取和更新
2. **避免直接访问字段**: 不要直接访问 `Task` 的内部字段,使用提供的方法
3. **使用快照进行读取**: 对于需要长时间持有的数据,使用 `Snapshot()` 创建快照
4. **使用 Update 进行更新**: 始终使用 `Update()` 方法进行更新,不要直接修改字段
5. **使用 race detector**: 使用 `go run -race` 检测并发安全问题

