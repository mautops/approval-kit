---
alwaysApply: true
---

# 审批流核心库技术实现方案

**版本**: 1.0.0  
**创建日期**: 2025-11-18
**状态**: Draft

## 1. 技术架构设计

### 1.1 整体架构

采用分层架构设计,核心层专注于状态管理和数据流转,通过接口抽象与上层业务系统解耦.

```
┌─────────────────────────────────────────┐
│        业务系统层 (外部实现)              │
│  - 数据持久化                            │
│  - 用户认证授权                          │
│  - API 接口                              │
└─────────────────┬───────────────────────┘
                  │ 接口抽象
┌─────────────────▼───────────────────────┐
│        审批流核心库                        │
│  ┌───────────────────────────────────┐  │
│  │  状态机引擎 (FSM)                  │  │
│  │  - 状态定义                        │  │
│  │  - 状态转换规则                    │  │
│  │  - 状态转换执行                    │  │
│  └───────────────────────────────────┘  │
│  ┌───────────────────────────────────┐  │
│  │  模板管理模块                      │  │
│  │  - 模板定义                        │  │
│  │  - 版本控制                        │  │
│  │  - 模板验证                        │  │
│  └───────────────────────────────────┘  │
│  ┌───────────────────────────────────┐  │
│  │  任务管理模块                      │  │
│  │  - 任务创建                        │  │
│  │  - 任务查询                        │  │
│  │  - 任务操作                        │  │
│  └───────────────────────────────────┘  │
│  ┌───────────────────────────────────┐  │
│  │  节点执行引擎                      │  │
│  │  - 节点激活                        │  │
│  │  - 节点执行                        │  │
│  │  - 上下文管理                      │  │
│  └───────────────────────────────────┘  │
│  ┌───────────────────────────────────┐  │
│  │  事件通知模块                      │  │
│  │  - 事件生成                        │  │
│  │  - 异步推送                        │  │
│  │  - 重试机制                        │  │
│  └───────────────────────────────────┘  │
│  ┌───────────────────────────────────┐  │
│  │  扩展接口层                        │  │
│  │  - HTTP 客户端接口                 │  │
│  │  - 条件评估接口                    │  │
│  │  - 存储接口                        │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

### 1.2 核心设计原则

1. **状态机驱动**: 使用有限状态机(FSM)管理任务状态流转,确保状态转换的合法性和一致性
2. **纯函数优先**: 状态转换逻辑使用纯函数实现,便于测试和推理
3. **不可变数据结构**: 优先使用不可变数据结构,减少并发问题
4. **接口抽象**: 通过小而专注的接口定义与外部系统的交互契约
5. **依赖注入**: 外部依赖通过接口注入,支持测试和扩展

## 2. 核心数据结构设计

### 2.1 审批模板 (Template)

```go
// Template 表示审批模板,不可变结构
type Template struct {
    ID          string    // 模板 ID
    Name        string    // 模板名称
    Description string    // 模板描述
    Version     int       // 版本号
    CreatedAt   time.Time // 创建时间
    UpdatedAt   time.Time // 更新时间

    // 节点定义
    Nodes map[string]*Node // 节点 ID -> 节点定义

    // 节点连接关系 (有向图)
    Edges []Edge // 边列表,定义节点间的连接

    // 全局配置
    Config *TemplateConfig // 模板全局配置
}

// Node 表示审批节点
type Node struct {
    ID          string      // 节点 ID
    Name        string      // 节点名称
    Type        NodeType    // 节点类型
    Order       int         // 节点顺序

    // 节点配置 (根据节点类型不同而不同)
    Config NodeConfig // 节点配置接口
}

// NodeType 节点类型
type NodeType string

const (
    NodeTypeStart    NodeType = "start"    // 开始节点
    NodeTypeApproval NodeType = "approval" // 审批节点
    NodeTypeCondition NodeType = "condition" // 条件节点
    NodeTypeEnd      NodeType = "end"      // 结束节点
)

// Edge 表示节点间的连接
type Edge struct {
    From   string // 源节点 ID
    To     string // 目标节点 ID
    Condition string // 条件表达式(可选,用于条件节点)
}
```

### 2.2 审批任务 (Task)

```go
// Task 表示审批任务实例,包含状态和运行时数据
type Task struct {
    mu sync.RWMutex // 读写锁,保证并发安全

    ID          string    // 任务 ID
    TemplateID  string    // 模板 ID
    TemplateVersion int    // 模板版本号
    BusinessID  string    // 关联的业务 ID
    Params      json.RawMessage // 任务参数(JSON 格式)

    // 状态信息
    State       TaskState // 当前状态
    CurrentNode string   // 当前节点 ID
    
    // 暂停相关字段
    PausedAt    *time.Time // 暂停时间
    PausedState TaskState  // 暂停前的状态,用于恢复时恢复到正确状态

    // 时间信息
    CreatedAt   time.Time // 创建时间
    UpdatedAt   time.Time // 更新时间
    SubmittedAt *time.Time // 提交时间

    // 运行时数据
    NodeOutputs map[string]json.RawMessage // 节点 ID -> 节点输出数据
    Approvers   map[string][]string       // 节点 ID -> 审批人列表
    Approvals   map[string]map[string]*Approval // 节点 ID -> 审批人 -> 审批结果
    
    // 回退相关字段
    CompletedNodes []string // 已完成的节点 ID 列表,用于回退操作

    // 审批记录
    Records []*Record // 审批记录列表

    // 状态变更历史
    StateHistory []*StateChange // 状态变更历史
}
```

// TaskState 任务状态
type TaskState string

const (
    TaskStatePending   TaskState = "pending"   // 待审批
    TaskStateSubmitted TaskState = "submitted" // 已提交
    TaskStateApproving TaskState = "approving" // 审批中
    TaskStateApproved  TaskState = "approved"  // 已通过
    TaskStateRejected  TaskState = "rejected"  // 已拒绝
    TaskStateCancelled TaskState = "cancelled" // 已取消
    TaskStateTimeout   TaskState = "timeout"   // 已超时
    TaskStatePaused    TaskState = "paused"    // 已暂停
)

// Record 审批记录
type Record struct {
    ID        string    // 记录 ID
    TaskID    string    // 任务 ID
    NodeID    string    // 节点 ID
    Approver  string    // 审批人
    Result    string    // 审批结果(approve/reject/transfer)
    Comment   string    // 审批意见
    CreatedAt time.Time // 审批时间
    Attachments []string // 附件列表
}
```

### 2.3 节点配置

```go
// NodeConfig 节点配置接口
type NodeConfig interface {
    NodeType() NodeType
    Validate() error
}

// ApprovalNodeConfig 审批节点配置
type ApprovalNodeConfig struct {
    // 审批模式
    Mode ApprovalMode // 审批模式

    // 审批人配置
    ApproverConfig ApproverConfig // 审批人配置

    // 其他配置
    Timeout        *time.Duration // 超时时间
    RejectBehavior RejectBehavior // 拒绝后行为
    Permissions    OperationPermissions // 操作权限
    RequireComment bool            // 是否必填审批意见
    RequireAttachments bool        // 是否要求附件
}

// ApprovalMode 审批模式
type ApprovalMode string

const (
    ApprovalModeSingle     ApprovalMode = "single"      // 单人审批
    ApprovalModeUnanimous  ApprovalMode = "unanimous"   // 多人会签
    ApprovalModeOr         ApprovalMode = "or"          // 多人或签
    ApprovalModeProportional ApprovalMode = "proportional" // 比例会签
    ApprovalModeSequential ApprovalMode = "sequential"   // 顺序审批
)

// ApproverConfig 审批人配置
type ApproverConfig interface {
    GetApprovers(ctx *NodeContext) ([]string, error)
    Timing() ApproverTiming // 获取时机
}

// FixedApproverConfig 固定审批人配置
type FixedApproverConfig struct {
    Approvers []string // 审批人列表
}

// DynamicApproverConfig 动态审批人配置
type DynamicApproverConfig struct {
    API          *HTTPAPIConfig // HTTP API 配置
    Timing       ApproverTiming // 获取时机
    HTTPClient   HTTPClient     // HTTP 客户端(依赖注入)
}
```

## 3. 状态机设计

### 3.1 状态定义

使用有限状态机(FSM)管理任务状态流转.状态转换必须通过状态机进行,确保合法性.

```go
// StateMachine 状态机接口
type StateMachine interface {
    // CanTransition 检查是否允许状态转换
    CanTransition(from TaskState, to TaskState) bool

    // Transition 执行状态转换
    Transition(task *Task, to TaskState, reason string) error

    // GetValidTransitions 获取当前状态的有效转换
    GetValidTransitions(state TaskState) []TaskState
}

// 状态转换规则
var stateTransitions = map[TaskState][]TaskState{
    // 待审批状态: 可以提交、取消或暂停
    TaskStatePending: {
        TaskStateSubmitted,
        TaskStateCancelled,
        TaskStatePaused,
    },
    
    // 已提交状态: 可以进入审批中、取消、撤回或暂停
    TaskStateSubmitted: {
        TaskStateApproving,
        TaskStateCancelled,
        TaskStatePending, // 撤回
        TaskStatePaused,
    },
    
    // 审批中状态: 可以批准、拒绝、取消、超时、撤回或暂停
    TaskStateApproving: {
        TaskStateApproved,
        TaskStateRejected,
        TaskStateCancelled,
        TaskStateTimeout,
        TaskStatePending, // 撤回
        TaskStatePaused,
    },
    
    // 已暂停状态: 可以恢复到暂停前的状态(待审批、已提交或审批中)
    // 注意: 恢复时需要记录暂停前的状态,恢复到对应状态
    TaskStatePaused: {
        TaskStatePending,
        TaskStateSubmitted,
        TaskStateApproving,
    },
    
    // 已通过状态: 终态,不允许转换
    TaskStateApproved: {},
    
    // 已拒绝状态: 终态,不允许转换
    TaskStateRejected: {},
    
    // 已取消状态: 终态,不允许转换
    TaskStateCancelled: {},
    
    // 已超时状态: 终态,不允许转换
    TaskStateTimeout: {},
}
```

**状态转换说明**:

- **暂停操作**: 可以从 `pending`、`submitted`、`approving` 状态暂停到 `paused` 状态
- **恢复操作**: 从 `paused` 状态恢复时,需要恢复到暂停前的状态.实现时需要记录暂停前的状态信息
- **回退操作**: `RollbackToNode` 操作可能涉及状态回退,需要根据回退的目标节点状态确定新的任务状态

### 3.2 状态转换实现

状态转换使用纯函数实现,确保可测试性和可追溯性.

```go
// Transition 执行状态转换(纯函数)
func Transition(task *Task, to TaskState, reason string, operator string) (*Task, error) {
    // 1. 验证状态转换合法性
    if !canTransition(task.State, to) {
        return nil, ErrInvalidStateTransition
    }

    // 2. 创建新任务对象(不可变)
    newTask := task.Clone()

    // 3. 更新状态
    newTask.State = to
    newTask.UpdatedAt = time.Now()

    // 4. 记录状态变更历史
    newTask.StateHistory = append(newTask.StateHistory, &StateChange{
        From:    task.State,
        To:      to,
        Reason:  reason,
        Operator: operator,
        Time:    time.Now(),
    })

    return newTask, nil
}
```

## 4. 节点执行引擎

### 4.1 节点上下文

节点执行时提供上下文信息,包含任务参数、节点输出数据等.

```go
// NodeContext 节点执行上下文
type NodeContext struct {
    Task      *Task              // 任务对象
    Node      *Node              // 当前节点
    Params    json.RawMessage    // 任务参数
    Outputs   map[string]json.RawMessage // 前面节点的输出数据
    Cache     *ContextCache      // 上下文缓存
}

// ContextCache 上下文缓存,避免重复查询
type ContextCache struct {
    mu    sync.RWMutex
    data  map[string]interface{}
}
```

### 4.2 节点执行器

不同节点类型有不同的执行器,通过接口抽象实现扩展.

```go
// NodeExecutor 节点执行器接口
type NodeExecutor interface {
    Execute(ctx *NodeContext) (*NodeResult, error)
    NodeType() NodeType
}

// NodeResult 节点执行结果
type NodeResult struct {
    NextNodeID string           // 下一个节点 ID
    Output     json.RawMessage  // 节点输出数据
    Events     []Event          // 生成的事件
}

// ApprovalNodeExecutor 审批节点执行器
type ApprovalNodeExecutor struct {
    config *ApprovalNodeConfig
}

func (e *ApprovalNodeExecutor) Execute(ctx *NodeContext) (*NodeResult, error) {
    // 1. 获取审批人列表
    approvers, err := e.config.ApproverConfig.GetApprovers(ctx)
    if err != nil {
        return nil, err
    }

    // 2. 检查审批状态
    approvals := ctx.Task.Approvals[ctx.Node.ID]
    result := e.checkApprovalStatus(approvers, approvals, e.config.Mode)

    // 3. 根据审批结果决定下一步
    if result.Completed {
        return &NodeResult{
            NextNodeID: result.NextNodeID,
            Output:     result.Output,
            Events:     result.Events,
        }, nil
    }

    // 审批未完成,等待更多审批
    return nil, ErrApprovalPending
}
```

## 5. 接口设计

### 5.1 核心接口

遵循接口隔离原则,设计小而专注的接口.

```go
// TemplateManager 模板管理接口
type TemplateManager interface {
    Create(template *Template) error
    Update(id string, template *Template) error
    Get(id string, version int) (*Template, error)
    Delete(id string) error
    ListVersions(id string) ([]int, error)
}

// TaskManager 任务管理接口
type TaskManager interface {
    Create(templateID string, businessID string, params json.RawMessage) (*Task, error)
    Get(id string) (*Task, error)
    Submit(id string) error
    Approve(id string, nodeID string, approver string, comment string) error
    Reject(id string, nodeID string, approver string, comment string) error
    Cancel(id string, reason string) error
    Withdraw(id string, reason string) error
    Transfer(id string, nodeID string, fromApprover string, toApprover string, reason string) error
    AddApprover(id string, nodeID string, approver string, reason string) error
    RemoveApprover(id string, nodeID string, approver string, reason string) error
    Pause(id string, reason string) error
    Resume(id string, reason string) error
    RollbackToNode(id string, nodeID string, reason string) error
    ReplaceApprover(id string, nodeID string, oldApprover string, newApprover string, reason string) error
    HandleTimeout(id string) error
    Query(filter *TaskFilter) ([]*Task, error)
}

// HTTPClient HTTP 客户端接口(用于动态审批人和条件节点)
type HTTPClient interface {
    Do(req *http.Request) (*http.Response, error)
}

// ConditionEvaluator 条件评估接口
type ConditionEvaluator interface {
    Evaluate(condition *Condition, ctx *NodeContext) (bool, error)
}
```

### 5.2 扩展接口

支持通过接口扩展实现自定义功能.

```go
// ApproverProvider 审批人提供者接口
type ApproverProvider interface {
    GetApprovers(ctx *NodeContext) ([]string, error)
}

// EventHandler 事件处理器接口
type EventHandler interface {
    Handle(event Event) error
}

// Storage 存储接口(由业务系统实现)
type Storage interface {
    SaveTemplate(template *Template) error
    LoadTemplate(id string, version int) (*Template, error)
    SaveTask(task *Task) error
    LoadTask(id string) (*Task, error)
}
```

### 5.3 TaskManager 接口完整定义

TaskManager 接口必须包含所有任务操作方法,确保后端 API 可以完整实现所有功能:

```go
// TaskManager 任务管理接口
type TaskManager interface {
    // 基础操作
    Create(templateID string, businessID string, params json.RawMessage) (*Task, error)
    Get(id string) (*Task, error)
    Submit(id string) error
    Cancel(id string, reason string) error
    Withdraw(id string, reason string) error
    
    // 审批操作
    Approve(id string, nodeID string, approver string, comment string) error
    Reject(id string, nodeID string, approver string, comment string) error
    
    // 高级操作
    Transfer(id string, nodeID string, fromApprover string, toApprover string, reason string) error
    AddApprover(id string, nodeID string, approver string, reason string) error
    RemoveApprover(id string, nodeID string, approver string, reason string) error
    ReplaceApprover(id string, nodeID string, oldApprover string, newApprover string, reason string) error
    
    // 暂停和恢复
    Pause(id string, reason string) error
    Resume(id string, reason string) error
    
    // 回退操作
    RollbackToNode(id string, nodeID string, reason string) error
    
    // 超时处理
    HandleTimeout(id string) error
    
    // 查询操作
    Query(filter *TaskFilter) ([]*Task, error)
}
```

## 6. 高级任务操作实现

### 6.1 任务暂停和恢复

#### 6.1.1 暂停操作实现

```go
// Pause 暂停任务
func (m *TaskManager) Pause(id string, reason string) error {
    // 1. 获取任务
    task, err := m.Get(id)
    if err != nil {
        return err
    }
    
    // 2. 验证当前状态允许暂停
    // 只有 pending、submitted、approving 状态可以暂停
    if !canPause(task.State) {
        return ErrInvalidStateTransition
    }
    
    // 3. 记录暂停前的状态
    pausedState := task.State
    
    // 4. 使用状态机转换到 paused 状态
    newTask, err := m.stateMachine.Transition(task, TaskStatePaused, reason)
    if err != nil {
        return err
    }
    
    // 5. 设置暂停相关字段
    now := time.Now()
    newTask.PausedAt = &now
    newTask.PausedState = pausedState
    
    // 6. 保存任务
    // 7. 生成暂停事件
    
    return nil
}

// canPause 检查是否可以暂停
func canPause(state TaskState) bool {
    return state == TaskStatePending || 
           state == TaskStateSubmitted || 
           state == TaskStateApproving
}
```

#### 6.1.2 恢复操作实现

```go
// Resume 恢复任务
func (m *TaskManager) Resume(id string, reason string) error {
    // 1. 获取任务
    task, err := m.Get(id)
    if err != nil {
        return err
    }
    
    // 2. 验证当前状态是 paused
    if task.State != TaskStatePaused {
        return ErrInvalidStateTransition
    }
    
    // 3. 获取暂停前的状态
    targetState := task.PausedState
    if targetState == "" {
        // 如果没有记录暂停前状态,默认恢复到 pending
        targetState = TaskStatePending
    }
    
    // 4. 使用状态机恢复到暂停前的状态
    newTask, err := m.stateMachine.Transition(task, targetState, reason)
    if err != nil {
        return err
    }
    
    // 5. 清除暂停相关字段
    newTask.PausedAt = nil
    newTask.PausedState = ""
    
    // 6. 保存任务
    // 7. 生成恢复事件
    
    return nil
}
```

### 6.2 回退到指定节点

```go
// RollbackToNode 回退到指定节点
func (m *TaskManager) RollbackToNode(id string, nodeID string, reason string) error {
    // 1. 获取任务和模板
    task, err := m.Get(id)
    if err != nil {
        return err
    }
    
    template, err := m.templateMgr.Get(task.TemplateID, task.TemplateVersion)
    if err != nil {
        return err
    }
    
    // 2. 验证节点存在且已完成
    if !contains(task.CompletedNodes, nodeID) {
        return ErrNodeNotFound
    }
    
    // 3. 验证回退的合法性
    // 回退的节点必须在当前节点之前
    if !isNodeBeforeCurrent(task, nodeID, template) {
        return ErrInvalidRollback
    }
    
    // 4. 清理回退节点之后的审批记录和状态
    // - 移除回退节点之后的审批记录
    // - 清除回退节点之后的节点输出数据
    // - 清除回退节点之后的审批人列表和审批结果
    
    // 5. 更新当前节点为回退的目标节点
    task.CurrentNode = nodeID
    
    // 6. 更新任务状态
    // 根据回退的节点类型确定新的状态
    targetState := determineStateAfterRollback(task, nodeID, template)
    newTask, err := m.stateMachine.Transition(task, targetState, reason)
    if err != nil {
        return err
    }
    
    // 7. 更新已完成节点列表
    newTask.CompletedNodes = removeNodesAfter(newTask.CompletedNodes, nodeID)
    
    // 8. 保存任务
    // 9. 生成回退事件
    
    return nil
}
```

### 6.3 替换审批人

```go
// ReplaceApprover 替换审批人
func (m *TaskManager) ReplaceApprover(id string, nodeID string, oldApprover string, newApprover string, reason string) error {
    // 1. 获取任务
    task, err := m.Get(id)
    if err != nil {
        return err
    }
    
    // 2. 验证当前节点和审批人
    if task.CurrentNode != nodeID {
        return ErrInvalidNode
    }
    
    // 3. 验证原审批人在审批人列表中
    approvers := task.Approvers[nodeID]
    if !contains(approvers, oldApprover) {
        return ErrApproverNotFound
    }
    
    // 4. 验证原审批人尚未审批
    approvals := task.Approvals[nodeID]
    if approvals != nil && approvals[oldApprover] != nil {
        return ErrApproverAlreadyApproved
    }
    
    // 5. 替换审批人
    // - 从审批人列表中移除原审批人
    // - 添加新审批人
    // - 保留原审批人的审批记录(如果有)
    
    // 6. 生成替换审批人记录
    record := &Record{
        ID:        generateID(),
        TaskID:    id,
        NodeID:    nodeID,
        Approver:  oldApprover,
        Result:    "replace",
        Comment:   fmt.Sprintf("替换为 %s: %s", newApprover, reason),
        CreatedAt: time.Now(),
    }
    task.Records = append(task.Records, record)
    
    // 7. 保存任务
    // 8. 生成替换审批人事件
    
    return nil
}
```

## 7. 事件通知机制

### 6.1 事件定义

```go
// Event 事件定义
type Event struct {
    Type      EventType       // 事件类型
    Time      time.Time       // 事件时间
    Task      *TaskInfo       // 任务信息
    Node      *NodeInfo       // 节点信息
    Approval  *ApprovalInfo   // 审批信息(如适用)
    Business  *BusinessInfo   // 业务信息
}

// EventType 事件类型
type EventType string

const (
    EventTypeTaskCreated    EventType = "task_created"
    EventTypeTaskSubmitted  EventType = "task_submitted"
    EventTypeNodeActivated  EventType = "node_activated"
    EventTypeApprovalOp     EventType = "approval_operation"
    EventTypeTaskApproved   EventType = "task_approved"
    EventTypeTaskRejected   EventType = "task_rejected"
    EventTypeTaskTimeout    EventType = "task_timeout"
    EventTypeTaskCancelled  EventType = "task_cancelled"
    EventTypeTaskPaused     EventType = "task_paused"
    EventTypeTaskResumed    EventType = "task_resumed"
    EventTypeTaskRollback   EventType = "task_rollback"
    EventTypeApproverReplaced EventType = "approver_replaced"
    EventTypeNodeCompleted  EventType = "node_completed"
)
```

### 6.2 异步推送

使用 goroutine 和 channel 实现异步事件推送,不阻塞主流程.

```go
// EventNotifier 事件通知器
type EventNotifier struct {
    handlers []EventHandler
    queue    chan Event
    wg       sync.WaitGroup
}

// Notify 异步推送事件
func (n *EventNotifier) Notify(event Event) {
    select {
    case n.queue <- event:
    default:
        // 队列满时记录日志,不阻塞
        log.Warn("event queue full, dropping event", "type", event.Type)
    }
}

// worker 事件处理 worker
func (n *EventNotifier) worker() {
    defer n.wg.Done()
    for event := range n.queue {
        n.pushEvent(event)
    }
}

// pushEvent 推送事件到所有处理器
func (n *EventNotifier) pushEvent(event Event) {
    for _, handler := range n.handlers {
        go func(h EventHandler) {
            if err := n.pushWithRetry(h, event); err != nil {
                log.Error("failed to push event", "error", err, "type", event.Type)
            }
        }(handler)
    }
}

// pushWithRetry 带重试的推送
func (n *EventNotifier) pushWithRetry(handler EventHandler, event Event) error {
    maxRetries := 3
    backoff := time.Second

    for i := 0; i < maxRetries; i++ {
        if err := handler.Handle(event); err == nil {
            return nil
        }
        if i < maxRetries-1 {
            time.Sleep(backoff)
            backoff *= 2
        }
    }
    return ErrEventPushFailed
}
```

## 8. 并发安全设计

### 7.1 任务并发控制

使用读写锁保护任务状态,支持并发读取,串行化写入.

```go
// Task 使用读写锁保护
type Task struct {
    mu sync.RWMutex
    // ... 其他字段
}

// Get 并发安全的读取
func (t *Task) Get() *TaskSnapshot {
    t.mu.RLock()
    defer t.mu.RUnlock()
    return t.snapshot()
}

// Update 并发安全的更新
func (t *Task) Update(fn func(*Task) error) error {
    t.mu.Lock()
    defer t.mu.Unlock()
    return fn(t)
}
```

### 7.2 状态转换原子性

状态转换使用乐观锁或版本号机制确保原子性.

```go
// Task 添加版本号
type Task struct {
    Version int64 // 版本号,用于乐观锁
    // ... 其他字段
}

// Transition 带版本检查的状态转换
func Transition(task *Task, to TaskState, expectedVersion int64) error {
    task.mu.Lock()
    defer task.mu.Unlock()

    if task.Version != expectedVersion {
        return ErrConcurrentModification
    }

    // 执行状态转换
    // ...
    task.Version++
    return nil
}
```

## 9. 错误处理

### 8.1 错误定义

定义明确的错误类型,支持错误分类和处理.

```go
// 错误定义
var (
    ErrInvalidTemplate      = errors.New("invalid template")
    ErrInvalidStateTransition = errors.New("invalid state transition")
    ErrNodeNotFound         = errors.New("node not found")
    ErrApproverNotFound     = errors.New("approver not found")
    ErrApprovalPending      = errors.New("approval pending")
    ErrConcurrentModification = errors.New("concurrent modification")
    ErrEventPushFailed      = errors.New("event push failed")
)

// 错误包装
type StateTransitionError struct {
    From TaskState
    To   TaskState
    Err  error
}

func (e *StateTransitionError) Error() string {
    return fmt.Sprintf("state transition failed: %s -> %s: %v", e.From, e.To, e.Err)
}

func (e *StateTransitionError) Unwrap() error {
    return e.Err
}
```

## 10. TDD 开发流程和规范 (不可协商)

### 9.1 TDD 核心原则

**TDD (Test-Driven Development, 测试驱动开发) 是本项目的核心开发原则,不可协商,必须严格遵循.**

TDD 是一种软件开发方法,强调在编写功能代码之前先编写测试代码.这种方法有助于确保代码质量,提高开发效率,并促进代码的可维护性.

#### 9.1.1 TDD 的基本流程

TDD 遵循"红-绿-重构"循环,包含以下三个阶段:

1. **红色阶段 (Red)**: 编写一个失败的测试用例,明确待实现的功能

   - 根据需求编写测试用例
   - 测试用例在当前代码下必须失败
   - 验证测试用例的有效性

2. **绿色阶段 (Green)**: 编写最少的代码,使测试通过

   - 仅编写足够的代码以使测试通过
   - 避免过度设计或实现未被测试覆盖的功能
   - 确保测试通过

3. **重构阶段 (Refactor)**: 优化代码结构,提升可读性和可维护性
   - 在测试通过的前提下重构代码
   - 提高代码质量,消除重复
   - 确保所有测试仍然通过

#### 9.1.2 TDD 工作流程

```
需求分析
    ↓
编写失败的测试用例 (Red)
    ↓
运行测试,确认失败
    ↓
编写最小化功能代码 (Green)
    ↓
运行测试,确认通过
    ↓
重构代码 (Refactor)
    ↓
运行测试,确认通过
    ↓
下一个功能/需求
```

### 9.2 Go 语言中的 TDD 实践

#### 9.2.1 测试文件组织

- **测试文件保存在独立文件夹中**,保持项目结构清晰简洁
- 测试目录结构: `tests/` 目录下按模块组织测试文件
- 测试文件命名: `*_test.go`
- 测试函数命名: `TestXxx`,其中 `Xxx` 为被测试的函数名

**项目结构示例**:

```
approval-kit/
├── internal/
│   ├── task/
│   │   └── task.go
│   ├── template/
│   │   └── template.go
│   └── statemachine/
│       └── fsm.go
└── tests/
    ├── task/
    │   └── task_test.go
    ├── template/
    │   └── template_test.go
    └── statemachine/
        └── fsm_test.go
```

```go
// tests/task/task_test.go
package task_test

import (
    "testing"
    "time"
    "github.com/approval-kit/internal/task"
)

func TestTaskCreate(t *testing.T) {
    // 测试代码
}
```

#### 9.2.2 表驱动测试

对于需要测试多种场景的函数,使用表驱动测试模式.

```go
func TestStateTransition(t *testing.T) {
    tests := []struct {
        name      string
        from      TaskState
        to        TaskState
        wantErr   bool
        wantErrMsg string
    }{
        {
            name:      "valid: pending to submitted",
            from:      TaskStatePending,
            to:        TaskStateSubmitted,
            wantErr:   false,
            wantErrMsg: "",
        },
        {
            name:      "invalid: approved to pending",
            from:      TaskStateApproved,
            to:        TaskStatePending,
            wantErr:   true,
            wantErrMsg: "invalid state transition",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := canTransition(tt.from, tt.to)
            if (err != nil) != tt.wantErr {
                t.Errorf("canTransition() error = %v, wantErr %v", err, tt.wantErr)
            }
            if tt.wantErr && err != nil && err.Error() != tt.wantErrMsg {
                t.Errorf("canTransition() error message = %v, want %v", err.Error(), tt.wantErrMsg)
            }
        })
    }
}
```

#### 9.2.3 测试工具和命令

使用 Go 标准库的 `testing` 包和 `go test` 命令:

```bash
# 运行所有测试(从 tests 目录)
go test ./tests/...

# 运行特定模块的测试
go test ./tests/task/...

# 运行特定测试函数
go test -run TestStateTransition ./tests/...

# 查看测试覆盖率
go test -cover ./tests/...

# 生成详细的覆盖率报告
go test -coverprofile=coverage.out ./tests/...
go tool cover -html=coverage.out
```

### 9.3 审批流核心库的 TDD 策略

#### 9.3.1 状态机测试

状态转换逻辑是核心功能,必须 100% 测试覆盖.

**TDD 步骤**:

1. **Red**: 编写状态转换测试用例

```go
func TestStateMachine_Transition(t *testing.T) {
    sm := NewStateMachine()

    // 测试合法转换
    err := sm.Transition(TaskStatePending, TaskStateSubmitted)
    assert.NoError(t, err)

    // 测试非法转换
    err = sm.Transition(TaskStateApproved, TaskStatePending)
    assert.Error(t, err)
    assert.Equal(t, ErrInvalidStateTransition, err)
}
```

2. **Green**: 实现状态机逻辑

```go
func (sm *StateMachine) Transition(from, to TaskState) error {
    if !sm.CanTransition(from, to) {
        return ErrInvalidStateTransition
    }
    // 实现转换逻辑
    return nil
}
```

3. **Refactor**: 优化代码结构,提取常量等

#### 9.3.2 节点执行器测试

节点执行器需要测试各种审批模式和边界情况.

**TDD 步骤**:

1. **Red**: 编写节点执行测试

```go
func TestApprovalNodeExecutor_Execute(t *testing.T) {
    config := &ApprovalNodeConfig{
        Mode: ApprovalModeUnanimous,
        ApproverConfig: &FixedApproverConfig{
            Approvers: []string{"user1", "user2"},
        },
    }
    executor := NewApprovalNodeExecutor(config)

    ctx := &NodeContext{
        Task: createTestTask(),
        Node: createTestNode(),
    }

    // 测试: 审批未完成
    result, err := executor.Execute(ctx)
    assert.Error(t, err)
    assert.Equal(t, ErrApprovalPending, err)

    // 测试: 所有审批人同意后完成
    // ... 添加审批记录
    result, err = executor.Execute(ctx)
    assert.NoError(t, err)
    assert.NotNil(t, result)
}
```

2. **Green**: 实现节点执行逻辑
3. **Refactor**: 提取公共逻辑,优化结构

#### 9.3.3 并发安全测试

使用 `go test -race` 检测并发安全问题.

```go
func TestTask_ConcurrentUpdate(t *testing.T) {
    task := createTestTask()

    // 并发更新测试
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            err := task.Update(func(t *Task) error {
                t.UpdatedAt = time.Now()
                return nil
            })
            assert.NoError(t, err)
        }()
    }
    wg.Wait()
}
```

运行并发测试:

```bash
go test -race ./tests/...
```

### 9.4 测试覆盖率要求

根据 Constitution 要求,测试覆盖率必须达到:

- **关键路径测试覆盖率**: 100%

  - 状态转换逻辑
  - 节点执行逻辑
  - 审批模式判断逻辑
  - 错误处理逻辑

- **整体测试覆盖率**: 不低于 80%
  - 所有公共 API
  - 核心业务逻辑
  - 工具函数

#### 9.4.1 覆盖率检查

```bash
# 检查覆盖率
go test -cover ./tests/...

# 生成覆盖率报告
go test -coverprofile=coverage.out ./tests/...
go tool cover -func=coverage.out

# 生成 HTML 报告
go tool cover -html=coverage.out -o coverage.html
```

#### 9.4.2 覆盖率检查命令

使用以下命令检查测试覆盖率:

```bash
# 运行测试并生成覆盖率报告
go test -coverprofile=coverage.out ./tests/...

# 查看覆盖率统计
go tool cover -func=coverage.out

# 生成 HTML 覆盖率报告
go tool cover -html=coverage.out -o coverage.html
```

### 9.5 测试类型和策略

#### 9.5.1 单元测试 (Unit Tests)

- **目标**: 测试单个函数或方法的行为
- **特点**: 快速、独立、可重复
- **要求**: 所有公共函数必须有单元测试

```go
func TestTemplate_Validate(t *testing.T) {
    tests := []struct {
        name    string
        template *Template
        wantErr bool
    }{
        {
            name: "valid template",
            template: &Template{
                ID:   "tpl-1",
                Name: "Test Template",
                Nodes: map[string]*Node{
                    "start": {ID: "start", Type: NodeTypeStart},
                },
            },
            wantErr: false,
        },
        {
            name: "missing start node",
            template: &Template{
                ID:   "tpl-2",
                Name: "Invalid Template",
                Nodes: map[string]*Node{},
            },
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := tt.template.Validate()
            if (err != nil) != tt.wantErr {
                t.Errorf("Template.Validate() error = %v, wantErr %v", err, tt.wantErr)
            }
        })
    }
}
```

#### 9.5.2 集成测试 (Integration Tests)

- **目标**: 测试多个组件协同工作的完整流程
- **特点**: 验证端到端流程,测试真实场景
- **要求**: 所有核心业务流程必须有集成测试

```go
func TestApprovalFlow_EndToEnd(t *testing.T) {
    // 1. 创建模板
    template := createTestTemplate()
    err := templateManager.Create(template)
    require.NoError(t, err)

    // 2. 创建任务
    task, err := taskManager.Create(template.ID, "business-1", json.RawMessage(`{"amount": 1000}`))
    require.NoError(t, err)
    assert.Equal(t, TaskStatePending, task.State)

    // 3. 提交任务
    err = taskManager.Submit(task.ID)
    require.NoError(t, err)
    task, _ = taskManager.Get(task.ID)
    assert.Equal(t, TaskStateApproving, task.State)

    // 4. 执行审批
    err = taskManager.Approve(task.ID, "node-1", "user-1", "approved")
    require.NoError(t, err)

    // 5. 验证最终状态
    task, err = taskManager.Get(task.ID)
    require.NoError(t, err)
    assert.Equal(t, TaskStateApproved, task.State)
    assert.Len(t, task.Records, 1)
}
```

#### 9.5.3 边界条件测试

必须测试以下边界情况:

- 空值/零值处理
- 最大值/最小值
- 并发访问
- 错误恢复
- 超时处理

```go
func TestTask_EdgeCases(t *testing.T) {
    t.Run("empty approver list", func(t *testing.T) {
        config := &ApprovalNodeConfig{
            ApproverConfig: &FixedApproverConfig{
                Approvers: []string{},
            },
        }
        err := config.Validate()
        assert.Error(t, err)
    })

    t.Run("nil task parameters", func(t *testing.T) {
        task, err := taskManager.Create("tpl-1", "biz-1", nil)
        require.NoError(t, err)
        assert.NotNil(t, task)
    })

    t.Run("concurrent approval", func(t *testing.T) {
        // 测试多个审批人同时审批
    })
}
```

### 9.6 测试最佳实践

#### 9.6.1 测试命名规范

- 测试函数名: `TestXxx`,清晰描述测试内容
- 使用表驱动测试时,每个测试用例的 `name` 字段应该清晰描述场景

```go
func TestStateMachine_CanTransition(t *testing.T) {
    // 好的命名
    tests := []struct {
        name    string
        from    TaskState
        to      TaskState
        want    bool
    }{
        {
            name: "valid: pending to submitted",
            from: TaskStatePending,
            to:   TaskStateSubmitted,
            want: true,
        },
        {
            name: "invalid: approved to pending (final state)",
            from: TaskStateApproved,
            to:   TaskStatePending,
            want: false,
        },
    }
}
```

#### 9.6.2 测试独立性

- 每个测试应该独立运行,不依赖其他测试
- 使用 `t.Parallel()` 支持并行执行(如果测试之间无依赖)

```go
func TestTask_Create(t *testing.T) {
    t.Parallel() // 支持并行执行

    task, err := taskManager.Create("tpl-1", "biz-1", nil)
    require.NoError(t, err)
    assert.NotNil(t, task)
}
```

#### 9.6.3 测试辅助函数

提取公共的测试辅助函数,减少重复代码.

```go
// test_helper.go
func createTestTemplate() *Template {
    return &Template{
        ID:   "test-template",
        Name: "Test Template",
        Nodes: map[string]*Node{
            "start": {
                ID:   "start",
                Type: NodeTypeStart,
            },
            "approval": {
                ID:   "approval",
                Type: NodeTypeApproval,
                Config: &ApprovalNodeConfig{
                    Mode: ApprovalModeSingle,
                    ApproverConfig: &FixedApproverConfig{
                        Approvers: []string{"user-1"},
                    },
                },
            },
            "end": {
                ID:   "end",
                Type: NodeTypeEnd,
            },
        },
        Edges: []Edge{
            {From: "start", To: "approval"},
            {From: "approval", To: "end"},
        },
    }
}

func createTestTask() *Task {
    return &Task{
        ID:         "test-task",
        TemplateID: "test-template",
        State:      TaskStatePending,
        CreatedAt:  time.Now(),
    }
}
```

#### 9.6.4 Mock 和 Stub

对于外部依赖(如 HTTP 客户端),使用接口和 Mock 实现.

```go
// HTTPClient 接口
type HTTPClient interface {
    Do(req *http.Request) (*http.Response, error)
}

// MockHTTPClient 用于测试
type MockHTTPClient struct {
    Response *http.Response
    Err      error
}

func (m *MockHTTPClient) Do(req *http.Request) (*http.Response, error) {
    return m.Response, m.Err
}

func TestDynamicApprover_Fetch(t *testing.T) {
    mockClient := &MockHTTPClient{
        Response: &http.Response{
            StatusCode: 200,
            Body:       io.NopCloser(strings.NewReader(`{"approvers": ["user-1", "user-2"]}`)),
        },
    }

    config := &DynamicApproverConfig{
        HTTPClient: mockClient,
    }

    approvers, err := config.GetApprovers(&NodeContext{})
    require.NoError(t, err)
    assert.Equal(t, []string{"user-1", "user-2"}, approvers)
}
```

### 9.7 TDD 工作流程检查清单

在实现每个功能时,必须遵循以下检查清单:

- [ ] **Red 阶段**

  - [ ] 根据需求编写测试用例
  - [ ] 测试用例明确描述预期行为
  - [ ] 运行测试,确认测试失败(红色)
  - [ ] 测试失败的原因符合预期

- [ ] **Green 阶段**

  - [ ] 编写最小化代码使测试通过
  - [ ] 运行测试,确认测试通过(绿色)
  - [ ] 没有实现未测试的功能

- [ ] **Refactor 阶段**

  - [ ] 重构代码,提高可读性
  - [ ] 消除代码重复
  - [ ] 运行所有测试,确认仍然通过
  - [ ] 检查代码覆盖率

- [ ] **完成检查**
  - [ ] 所有测试通过
  - [ ] 代码覆盖率达标(关键路径 100%,整体 80%+)
  - [ ] 代码通过 `go vet` 检查
  - [ ] 代码通过 `golangci-lint` 检查
  - [ ] 代码符合 Go 代码规范

### 9.8 TDD 常见问题和解决方案

#### 9.8.1 测试难以编写

**问题**: 代码耦合度高,难以测试

**解决方案**:

- 使用依赖注入,通过接口抽象外部依赖
- 将复杂函数拆分为更小的函数
- 使用接口隔离原则,设计小而专注的接口

#### 9.8.2 测试运行缓慢

**问题**: 测试执行时间过长,影响开发效率

**解决方案**:

- 使用单元测试而非集成测试进行快速反馈
- 使用 `t.Parallel()` 并行执行独立测试
- 避免在测试中进行 I/O 操作,使用 Mock

#### 9.8.3 测试维护成本高

**问题**: 代码变更导致大量测试需要更新

**解决方案**:

- 测试应该关注行为而非实现细节
- 使用表驱动测试减少重复代码
- 提取测试辅助函数,提高复用性

## 11. 测试策略

### 10.1 单元测试

所有核心功能必须包含单元测试,使用表驱动测试.

```go
func TestStateTransition(t *testing.T) {
    tests := []struct {
        name      string
        from      TaskState
        to        TaskState
        wantErr   bool
    }{
        {
            name:    "valid transition: pending to submitted",
            from:    TaskStatePending,
            to:      TaskStateSubmitted,
            wantErr: false,
        },
        {
            name:    "invalid transition: approved to pending",
            from:    TaskStateApproved,
            to:      TaskStatePending,
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := canTransition(tt.from, tt.to)
            if (err != nil) != tt.wantErr {
                t.Errorf("canTransition() error = %v, wantErr %v", err, tt.wantErr)
            }
        })
    }
}
```

### 10.2 集成测试

状态转换逻辑必须包含集成测试,验证完整流程.

```go
func TestApprovalFlow(t *testing.T) {
    // 1. 创建模板
    template := createTestTemplate()

    // 2. 创建任务
    task, err := taskManager.Create(template.ID, "business-1", nil)
    require.NoError(t, err)

    // 3. 提交任务
    err = taskManager.Submit(task.ID)
    require.NoError(t, err)

    // 4. 执行审批
    err = taskManager.Approve(task.ID, "node-1", "user-1", "approved")
    require.NoError(t, err)

    // 5. 验证最终状态
    task, err = taskManager.Get(task.ID)
    require.NoError(t, err)
    assert.Equal(t, TaskStateApproved, task.State)
}
```

## 12. 性能优化

### 11.1 内存优化

- 使用对象池复用任务对象
- 审批记录使用切片预分配容量
- 节点输出数据使用 JSON 原始格式,避免多次序列化

### 11.2 并发优化

- 使用读写锁支持并发读取
- 状态转换使用 channel 串行化处理
- 事件推送使用 worker pool 模式

## 13. 依赖管理

### 12.1 标准库优先

优先使用 Go 标准库,最小化外部依赖.

- `encoding/json`: JSON 序列化/反序列化
- `net/http`: HTTP 客户端(标准库)
- `sync`: 并发控制
- `time`: 时间处理
- `context`: 上下文管理

### 12.2 可选依赖

仅在必要时引入第三方库,并充分论证.

- 如需更强大的 HTTP 客户端功能,可考虑 `golang.org/x/net/http2`
- 如需更复杂的条件表达式解析,可考虑轻量级表达式引擎

## 14. 扩展点设计

### 13.1 审批模式扩展

通过接口实现自定义审批模式.

```go
// ApprovalModeHandler 审批模式处理器接口
type ApprovalModeHandler interface {
    CheckCompletion(approvers []string, approvals map[string]*Approval) (bool, *ApprovalResult)
}
```

### 13.2 条件评估扩展

支持自定义条件评估器.

```go
// ConditionEvaluator 条件评估器接口
type ConditionEvaluator interface {
    Evaluate(condition *Condition, ctx *NodeContext) (bool, error)
    Supports(conditionType string) bool
}
```

## 15. 实现优先级

### Phase 1: 核心功能 (P0)

1. 模板管理基础功能
2. 任务创建和状态管理
3. 基础状态机实现
4. 简单审批节点执行

### Phase 2: 完整功能 (P1)

1. 所有审批模式支持
2. 动态审批人获取
3. 条件节点支持
4. 审批记录生成

### Phase 3: 高级功能 (P2)

1. 事件通知机制
2. 超时处理
3. 拒绝后跳转
4. 转交、加签、减签等操作
5. 任务暂停和恢复
6. 回退到指定节点
7. 替换审批人

## 16. 技术选型总结

| 技术点      | 选型                        | 理由                       |
| ----------- | --------------------------- | -------------------------- |
| 状态管理    | 有限状态机(FSM)             | 确保状态转换合法性和一致性 |
| 数据结构    | 不可变优先                  | 减少并发问题,便于测试      |
| 并发控制    | sync.RWMutex                | 标准库,支持并发读取        |
| HTTP 客户端 | net/http                    | 标准库,满足需求            |
| JSON 处理   | encoding/json               | 标准库,满足需求            |
| 事件推送    | goroutine + channel         | 标准库,异步非阻塞          |
| 错误处理    | error 接口 + 自定义错误类型 | Go 语言惯用法              |
| 接口设计    | 小而专注的接口              | 遵循接口隔离原则           |
| 测试框架    | testing 包                  | 标准库,满足 TDD 需求       |

## 17. 风险评估

### 16.1 技术风险

- **状态一致性**: 通过状态机和版本号机制保证
- **并发安全**: 使用读写锁和乐观锁机制
- **性能瓶颈**: 通过对象池和 worker pool 优化

### 16.2 设计风险

- **过度设计**: 严格遵循 YAGNI 原则,避免过早优化
- **接口变更**: 遵循语义化版本控制,保证向后兼容

## 18. 公共 API 暴露 (pkg 目录)

### 18.1 背景和需求

由于 Go 语言的 `internal` 包限制,`internal` 目录下的包只能被同一模块内的包导入,不能被外部模块导入.这导致 `approval-gin` 等外部项目无法直接使用 `approval-kit` 的 `internal` 包中的接口和类型.

为了解决这个问题,需要将 `internal` 包中需要被外部使用的接口和类型暴露到 `pkg` 目录下.`pkg` 目录是 Go 社区约定用于暴露公共 API 的目录,可以被外部模块导入.

### 18.2 需要暴露的内容

根据 `approval-gin` 的使用情况,需要暴露以下内容:

#### 18.2.1 接口 (Interfaces)

- **TaskManager**: 任务管理接口 (`internal/task/manager.go`)
  - 包含所有任务操作方法: Create, Get, Submit, Approve, Reject, Cancel, Withdraw, Transfer, AddApprover, RemoveApprover, Pause, Resume, RollbackToNode, ReplaceApprover, HandleTimeout, Query

- **TemplateManager**: 模板管理接口 (`internal/template/manager.go`)
  - 包含模板管理操作: Create, Update, Get, Delete, ListVersions

- **EventHandler**: 事件处理器接口 (`internal/event/handler.go`)
  - 用于处理审批流程中的事件通知

- **StateMachine**: 状态机接口 (`internal/statemachine/fsm.go`)
  - 管理审批任务的状态流转: CanTransition, Transition, GetValidTransitions

- **TransitionableTask**: 状态转换任务接口 (`internal/statemachine/task_interface.go`)
  - 定义状态转换所需的任务接口: GetState, SetState, GetUpdatedAt, SetUpdatedAt, GetStateHistory, AddStateChange, Clone

- **NodeConfig**: 节点配置接口 (`internal/template/node.go`)
  - 节点配置的基础接口: NodeType, Validate

- **ApprovalNodeConfigAccessor**: 审批节点配置访问接口 (`internal/template/node.go`)
  - 用于访问审批节点配置的属性: RequireComment, RequireAttachments, GetTimeout, GetPermissions, GetRejectBehavior, GetRejectTargetNode

- **OperationPermissionsAccessor**: 操作权限访问接口 (`internal/template/node.go`)
  - 用于访问操作权限配置: AllowTransfer, AllowAddApprover, AllowRemoveApprover

#### 18.2.2 类型 (Types)

**任务相关类型**:
- **Task**: 审批任务实例 (`internal/task/task.go`)
- **TaskState**: 任务状态类型和常量 (`internal/types/state.go` - 已在 `pkg/types` 中)
- **TaskFilter**: 任务查询过滤器 (`internal/task/filter.go`)
- **Approval**: 审批结果 (`internal/task/task.go`)
- **Record**: 审批记录 (`internal/task/task.go`)
- **StateChange**: 状态变更记录 (`internal/task/task.go` 和 `internal/statemachine/task_interface.go`)

**模板相关类型**:
- **Template**: 审批模板 (`internal/template/template.go`)
- **Node**: 审批节点 (`internal/template/node.go`)
- **Edge**: 节点间的连接 (`internal/template/edge.go`)
- **NodeType**: 节点类型和常量 (`internal/template/node_type.go`)
- **TemplateConfig**: 模板全局配置 (`internal/template/template.go`)
- **WebhookConfig**: Webhook 配置 (`internal/template/template.go`)
- **AuthConfig**: 认证配置 (`internal/template/template.go`)

**事件相关类型**:
- **Event**: 事件定义 (`internal/event/event.go`)
- **EventType**: 事件类型和常量 (`internal/event/event.go`)
- **TaskInfo**: 任务信息 (`internal/event/event.go`)
- **NodeInfo**: 节点信息 (`internal/event/event.go`)
- **ApprovalInfo**: 审批信息 (`internal/event/event.go`)
- **BusinessInfo**: 业务信息 (`internal/event/event.go`)

### 18.3 pkg 目录结构设计

```
pkg/
├── task/                    # 任务相关公共 API
│   ├── manager.go          # TaskManager 接口
│   ├── task.go             # Task 类型
│   ├── filter.go           # TaskFilter 类型
│   └── types.go            # Approval, Record, StateChange 类型
├── template/               # 模板相关公共 API
│   ├── manager.go          # TemplateManager 接口
│   ├── template.go         # Template, TemplateConfig, WebhookConfig, AuthConfig 类型
│   ├── node.go             # Node, NodeConfig, ApprovalNodeConfigAccessor, OperationPermissionsAccessor 接口
│   ├── edge.go             # Edge 类型
│   └── node_type.go        # NodeType 类型和常量
├── event/                  # 事件相关公共 API
│   ├── handler.go          # EventHandler 接口
│   └── event.go            # Event, EventType, TaskInfo, NodeInfo, ApprovalInfo, BusinessInfo 类型
├── statemachine/           # 状态机相关公共 API
│   ├── fsm.go              # StateMachine 接口
│   └── task_interface.go   # TransitionableTask 接口和 StateChange 类型
└── types/                  # 基础类型 (已存在)
    └── state.go            # TaskState 类型和常量
```

### 18.4 实现策略

#### 18.4.1 类型别名策略

为了避免代码重复和维护成本,采用类型别名策略:

1. **接口**: 在 `pkg` 目录中重新定义接口,与 `internal` 中的接口保持一致
2. **类型**: 对于结构体类型,在 `pkg` 目录中定义相同的类型,通过类型转换与 `internal` 类型互操作
3. **常量**: 在 `pkg` 目录中重新定义常量,确保值一致

#### 18.4.2 适配器模式

对于需要将 `internal` 类型转换为 `pkg` 类型的场景,使用适配器函数:

```go
// pkg/task/task.go
package task

import (
    internalTask "github.com/mautops/approval-kit/internal/task"
)

// Task 表示审批任务实例
// 与 internal/task.Task 结构相同,但位于 pkg 目录,可以被外部导入
type Task = internalTask.Task

// ToInternal 将 pkg.Task 转换为 internal.Task
func ToInternal(t *Task) *internalTask.Task {
    return (*internalTask.Task)(t)
}

// FromInternal 将 internal.Task 转换为 pkg.Task
func FromInternal(t *internalTask.Task) *Task {
    return (*Task)(t)
}
```

#### 18.4.3 接口实现

对于接口,需要在 `pkg` 目录中重新定义,确保与 `internal` 中的接口定义完全一致:

```go
// pkg/task/manager.go
package task

import "encoding/json"

// TaskManager 任务管理接口
// 与 internal/task.TaskManager 接口定义完全一致
type TaskManager interface {
    Create(templateID string, businessID string, params json.RawMessage) (*Task, error)
    Get(id string) (*Task, error)
    Submit(id string) error
    // ... 其他方法
}
```

### 18.5 兼容性保证

1. **接口稳定性**: `pkg` 目录中的接口必须保持稳定,遵循语义化版本控制
2. **类型一致性**: `pkg` 目录中的类型必须与 `internal` 目录中的类型保持一致
3. **向后兼容**: 新版本必须保持向后兼容,不能破坏现有 API

### 18.6 文档要求

所有 `pkg` 目录下的公共 API 必须包含完整的文档注释:

- 接口用途说明
- 方法参数和返回值说明
- 使用示例
- 注意事项和最佳实践

## 19. 后续优化方向

1. 支持更复杂的条件表达式
2. 支持并行网关和排他网关
3. 支持子流程
4. 支持任务暂停和恢复
5. 性能基准测试和优化
6. 完善 pkg 目录的公共 API 暴露
